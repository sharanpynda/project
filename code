import { ComponentFixture, TestBed } from '@angular/core/testing';
import { NasTableComponent } from './nas-table.component';
import { of } from 'rxjs';
import { BackEndService } from 'src/app/_services/backend.service';
import { MatDialog } from '@angular/material/dialog';
import { ActivatedRoute, Router } from '@angular/router';
import { EntitlementService } from 'src/app/_services/entitlement.service';
import { DesignLayoutComponent } from '../../../_layouts/design-layout/design-layout.component';
import { ResourceStatus } from 'src/app/shared/models/resource';
import { NasVolumes } from 'src/app/shared/models/nas';

describe('NasTableComponent', () => {
  let component: NasTableComponent;
  let fixture: ComponentFixture<NasTableComponent>;
  let backendService: jest.Mocked<BackEndService>;
  let dialog: jest.Mocked<MatDialog>;
  let entitlementService: jest.Mocked<EntitlementService>;
  let router: jest.Mocked<Router>;
  let route: ActivatedRoute;
  let designLayoutComponent: DesignLayoutComponent;

  beforeEach(async () => {
    backendService = {
      use: jest.fn().mockReturnThis(),
    };
    dialog = {
      open: jest.fn(),
    };
    entitlementService = {
      hasEntitlement: jest.fn(),
    };
    router = {
      navigateByUrl: jest.fn(),
      navigate: jest.fn(),
    };
    route = {} as ActivatedRoute;
    designLayoutComponent = {} as DesignLayoutComponent;

    await TestBed.configureTestingModule({
      imports: [NasTableComponent],
      providers: [
        { provide: BackEndService, useValue: backendService },
        { provide: MatDialog, useValue: dialog },
        { provide: EntitlementService, useValue: entitlementService },
        { provide: Router, useValue: router },
        { provide: ActivatedRoute, useValue: route },
        { provide: DesignLayoutComponent, useValue: designLayoutComponent }
      ]
    }).compileComponents();

    fixture = TestBed.createComponent(NasTableComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });

  it('should subscribe to parent layout and get data', () => {
    const layoutData = {
      appl: { id: 1 },
      design: { id: 2, isEditable: true },
      HldEntitlement: true,
      resourceUpdateEntitlement: true
    };

    designLayoutComponent.layoutData$ = of(layoutData);
    fixture.detectChanges();

    expect(component.appId).toBe(1);
    expect(component.designId).toBe(2);
    expect(component.readOnly).toBe(false);
  });

  it('should display update buttons if isEditable and HldEntitlement && resourceUpdateEntitlement', () => {
    const layoutData = {
      appl: { id: 1 },
      design: { id: 2, isEditable: true },
      HldEntitlement: true,
      resourceUpdateEntitlement: true
    };

    designLayoutComponent.layoutData$ = of(layoutData);
    fixture.detectChanges();

    expect(component.buttons).toEqual(component.updateButtons);
  });

  it('should display readonly buttons if NOT isEditable', () => {
    const layoutData = {
      appl: { id: 1 },
      design: { id: 2, isEditable: false },
      HldEntitlement: true,
      resourceUpdateEntitlement: true
    };

    designLayoutComponent.layoutData$ = of(layoutData);
    fixture.detectChanges();

    expect(component.buttons).toEqual(component.readOnlyButtons);
  });

  it('should display readonly buttons if NOT HldEntitlement', () => {
    const layoutData = {
      appl: { id: 1 },
      design: { id: 2, isEditable: true },
      HldEntitlement: false,
      resourceUpdateEntitlement: true
    };

    designLayoutComponent.layoutData$ = of(layoutData);
    fixture.detectChanges();

    expect(component.buttons).toEqual(component.readOnlyButtons);
  });

  it('should display readonly buttons if NOT resourceUpdateEntitlement', () => {
    const layoutData = {
      appl: { id: 1 },
      design: { id: 2, isEditable: true },
      HldEntitlement: true,
      resourceUpdateEntitlement: false
    };

    designLayoutComponent.layoutData$ = of(layoutData);
    fixture.detectChanges();

    expect(component.buttons).toEqual(component.readOnlyButtons);
  });

  it('should retrieve and display NAS data from backend', () => {
    const mockData: NasVolumes[] = [
      { id: 1, friendlyName: 'NAS1', status: ResourceStatus.NEW, otherField: 'some data' }
    ];
    backendService.use.mockReturnValue({ with: jest.fn().mockReturnValue({ get: jest.fn().mockReturnValue(of(mockData)) }) });

    component.retrieve().subscribe(data => {
      expect(data).toEqual(mockData);
    });
  });

  it('should display undo action if row is New', () => {
    const row: NasVolumes = { id: 1, friendlyName: 'NAS1', status: ResourceStatus.NEW, otherField: 'some data' };
    fixture.detectChanges();

    const undoButton = fixture.nativeElement.querySelector('.undo-button');
    expect(undoButton).toBeTruthy();
  });

  it('should display undo action if row is Modified', () => {
    const row: NasVolumes = { id: 1, friendlyName: 'NAS1', status: ResourceStatus.MODIFIED, otherField: 'some data' };
    fixture.detectChanges();

    const undoButton = fixture.nativeElement.querySelector('.undo-button');
    expect(undoButton).toBeTruthy();
  });

  it('should display delete action if row is existing', () => {
    const row: NasVolumes = { id: 1, friendlyName: 'NAS1', status: ResourceStatus.EXISTING, otherField: 'some data' };
    fixture.detectChanges();

    const deleteButton = fixture.nativeElement.querySelector('.delete-button');
    expect(deleteButton).toBeTruthy();
  });

  it('should display are-you-sure-dialog when delete button is pressed', () => {
    const row: NasVolumes = { id: 1, friendlyName: 'NAS1', status: ResourceStatus.EXISTING, otherField: 'some data' };
    dialog.open.mockReturnValue({ afterClosed: jest.fn().mockReturnValue(of('Delete')) });

    component.deleteRow(row);
    expect(dialog.open).toHaveBeenCalled();
  });

  it('should display are-you-sure-dialog when undo row-action is pressed for a Modified status', () => {
    const row: NasVolumes = { id: 1, friendlyName: 'NAS1', status: ResourceStatus.MODIFIED, otherField: 'some data' };
    dialog.open.mockReturnValue({ afterClosed: jest.fn().mockReturnValue(of('Revert')) });

    component.revert(row);
    expect(dialog.open).toHaveBeenCalled();
  });

  it('should display are-you-sure-dialog-this-can-not-be-reverted when undo row-action is pressed for a New status', () => {
    const row: NasVolumes = { id: 1, friendlyName: 'NAS1', status: ResourceStatus.NEW, otherField: 'some data' };
    dialog.open.mockReturnValue({ afterClosed: jest.fn().mockReturnValue(of('Revert')) });

    component.revert(row);
    expect(dialog.open).toHaveBeenCalled();
  });

  it('should do nothing when cancel is selected in delete-dialog', () => {
    const row: NasVolumes = { id: 1, friendlyName: 'NAS1', status: ResourceStatus.EXISTING, otherField: 'some data' };
    dialog.open.mockReturnValue({ afterClosed: jest.fn().mockReturnValue(of('Cancel')) });

    component.deleteRow(row);
    expect(backendService.use).not.toHaveBeenCalled();
  });

  it('should call back-end delete when delete is selected in delete dialog', () => {
    const row: NasVolumes = { id: 1, friendlyName: 'NAS1', status: ResourceStatus.EXISTING, otherField: 'some data' };
    dialog.open.mockReturnValue({ afterClosed: jest.fn().mockReturnValue(of('Delete')) });
    backendService.use.mockReturnValue({ with: jest.fn().mockReturnValue({ delete: jest.fn().mockReturnValue(of(null)) }) });

    component.deleteRow(row);
    expect(backendService.use).toHaveBeenCalled();
  });

  it('should update row in dataset (to Deleted status) when back-end delete is called', () => {
    const row: NasVolumes = { id: 1, friendlyName: 'NAS1', status: ResourceStatus.EXISTING, otherField: 'some data' };
    dialog.open.mockReturnValue({ afterClosed: jest.fn().mockReturnValue(of('Delete')) });
    backendService.use.mockReturnValue({ with: jest.fn().mockReturnValue({ delete: jest.fn().mockReturnValue(of(null)) }) });

    component.deleteRow(row);
    expect(component.dataSource.data.some(r => r.status === Resource
